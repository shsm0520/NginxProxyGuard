package repository

import (
	"context"
	"database/sql"
	"fmt"
	"log"

	"nginx-proxy-guard/internal/model"
	"nginx-proxy-guard/pkg/cache"
)

// ExploitBlockRuleRepository handles exploit blocking rule database operations
type ExploitBlockRuleRepository struct {
	db    *sql.DB
	cache *cache.RedisClient
}

// NewExploitBlockRuleRepository creates a new exploit block rule repository
func NewExploitBlockRuleRepository(db *sql.DB) *ExploitBlockRuleRepository {
	return &ExploitBlockRuleRepository{db: db}
}

// SetCache sets the cache client for the repository
func (r *ExploitBlockRuleRepository) SetCache(c *cache.RedisClient) {
	r.cache = c
}

// GetAll returns all exploit block rules
func (r *ExploitBlockRuleRepository) GetAll(ctx context.Context) ([]model.ExploitBlockRule, error) {
	query := `
		SELECT id, category, name, pattern, pattern_type,
		       COALESCE(description, '') as description,
		       severity, enabled, is_system, sort_order,
		       created_at, updated_at
		FROM exploit_block_rules
		ORDER BY category, sort_order, name`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query exploit rules: %w", err)
	}
	defer rows.Close()

	var rules []model.ExploitBlockRule
	for rows.Next() {
		var rule model.ExploitBlockRule
		if err := rows.Scan(
			&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
			&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
			&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan exploit rule: %w", err)
		}
		rules = append(rules, rule)
	}
	return rules, rows.Err()
}

// GetEnabled returns only enabled rules (not globally excluded)
func (r *ExploitBlockRuleRepository) GetEnabled(ctx context.Context) ([]model.ExploitBlockRule, error) {
	// Try cache first
	if r.cache != nil {
		var cached []model.ExploitBlockRule
		if err := r.cache.GetEnabledExploitRules(ctx, &cached); err == nil {
			return cached, nil
		}
	}

	query := `
		SELECT r.id, r.category, r.name, r.pattern, r.pattern_type,
		       COALESCE(r.description, '') as description,
		       r.severity, r.enabled, r.is_system, r.sort_order,
		       r.created_at, r.updated_at
		FROM exploit_block_rules r
		LEFT JOIN global_exploit_rule_exclusions ge ON r.id = ge.rule_id
		WHERE r.enabled = true AND ge.id IS NULL
		ORDER BY r.category, r.sort_order, r.name`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query enabled exploit rules: %w", err)
	}
	defer rows.Close()

	var rules []model.ExploitBlockRule
	for rows.Next() {
		var rule model.ExploitBlockRule
		if err := rows.Scan(
			&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
			&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
			&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan exploit rule: %w", err)
		}
		rules = append(rules, rule)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	// Cache the result
	if r.cache != nil {
		if err := r.cache.SetEnabledExploitRules(ctx, rules); err != nil {
			log.Printf("[Cache] Failed to cache enabled exploit rules: %v", err)
		}
	}

	return rules, nil
}

// GetEnabledForHost returns enabled rules for a specific host (excluding host-specific exclusions)
func (r *ExploitBlockRuleRepository) GetEnabledForHost(ctx context.Context, hostID string) ([]model.ExploitBlockRule, error) {
	query := `
		SELECT r.id, r.category, r.name, r.pattern, r.pattern_type,
		       COALESCE(r.description, '') as description,
		       r.severity, r.enabled, r.is_system, r.sort_order,
		       r.created_at, r.updated_at
		FROM exploit_block_rules r
		LEFT JOIN global_exploit_rule_exclusions ge ON r.id = ge.rule_id
		LEFT JOIN host_exploit_rule_exclusions he ON r.id = he.rule_id AND he.proxy_host_id = $1
		WHERE r.enabled = true AND ge.id IS NULL AND he.id IS NULL
		ORDER BY r.category, r.sort_order, r.name`

	rows, err := r.db.QueryContext(ctx, query, hostID)
	if err != nil {
		return nil, fmt.Errorf("failed to query exploit rules for host: %w", err)
	}
	defer rows.Close()

	var rules []model.ExploitBlockRule
	for rows.Next() {
		var rule model.ExploitBlockRule
		if err := rows.Scan(
			&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
			&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
			&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan exploit rule: %w", err)
		}
		rules = append(rules, rule)
	}
	return rules, rows.Err()
}

// GetByID returns a single rule by ID
func (r *ExploitBlockRuleRepository) GetByID(ctx context.Context, id string) (*model.ExploitBlockRule, error) {
	query := `
		SELECT id, category, name, pattern, pattern_type,
		       COALESCE(description, '') as description,
		       severity, enabled, is_system, sort_order,
		       created_at, updated_at
		FROM exploit_block_rules
		WHERE id = $1`

	var rule model.ExploitBlockRule
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
		&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
		&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get exploit rule: %w", err)
	}
	return &rule, nil
}

// GetByCategory returns rules by category
func (r *ExploitBlockRuleRepository) GetByCategory(ctx context.Context, category string) ([]model.ExploitBlockRule, error) {
	query := `
		SELECT id, category, name, pattern, pattern_type,
		       COALESCE(description, '') as description,
		       severity, enabled, is_system, sort_order,
		       created_at, updated_at
		FROM exploit_block_rules
		WHERE category = $1
		ORDER BY sort_order, name`

	rows, err := r.db.QueryContext(ctx, query, category)
	if err != nil {
		return nil, fmt.Errorf("failed to query exploit rules by category: %w", err)
	}
	defer rows.Close()

	var rules []model.ExploitBlockRule
	for rows.Next() {
		var rule model.ExploitBlockRule
		if err := rows.Scan(
			&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
			&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
			&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan exploit rule: %w", err)
		}
		rules = append(rules, rule)
	}
	return rules, rows.Err()
}

// Create creates a new custom exploit rule
func (r *ExploitBlockRuleRepository) Create(ctx context.Context, req *model.CreateExploitRuleRequest) (*model.ExploitBlockRule, error) {
	severity := req.Severity
	if severity == "" {
		severity = "warning"
	}

	query := `
		INSERT INTO exploit_block_rules (category, name, pattern, pattern_type, description, severity, is_system, sort_order)
		VALUES ($1, $2, $3, $4, $5, $6, false,
		        COALESCE((SELECT MAX(sort_order) + 1 FROM exploit_block_rules WHERE category = $1), 100))
		RETURNING id, category, name, pattern, pattern_type, COALESCE(description, ''), severity, enabled, is_system, sort_order, created_at, updated_at`

	var rule model.ExploitBlockRule
	err := r.db.QueryRowContext(ctx, query,
		req.Category, req.Name, req.Pattern, req.PatternType, req.Description, severity,
	).Scan(
		&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
		&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
		&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create exploit rule: %w", err)
	}

	r.invalidateCache(ctx)
	return &rule, nil
}

// Update updates an exploit rule
func (r *ExploitBlockRuleRepository) Update(ctx context.Context, id string, req *model.UpdateExploitRuleRequest) (*model.ExploitBlockRule, error) {
	setClauses := []string{"updated_at = CURRENT_TIMESTAMP"}
	args := []interface{}{}
	argIndex := 1

	if req.Name != nil {
		setClauses = append(setClauses, fmt.Sprintf("name = $%d", argIndex))
		args = append(args, *req.Name)
		argIndex++
	}
	if req.Pattern != nil {
		setClauses = append(setClauses, fmt.Sprintf("pattern = $%d", argIndex))
		args = append(args, *req.Pattern)
		argIndex++
	}
	if req.PatternType != nil {
		setClauses = append(setClauses, fmt.Sprintf("pattern_type = $%d", argIndex))
		args = append(args, *req.PatternType)
		argIndex++
	}
	if req.Description != nil {
		setClauses = append(setClauses, fmt.Sprintf("description = $%d", argIndex))
		args = append(args, *req.Description)
		argIndex++
	}
	if req.Severity != nil {
		setClauses = append(setClauses, fmt.Sprintf("severity = $%d", argIndex))
		args = append(args, *req.Severity)
		argIndex++
	}
	if req.Enabled != nil {
		setClauses = append(setClauses, fmt.Sprintf("enabled = $%d", argIndex))
		args = append(args, *req.Enabled)
		argIndex++
	}

	if len(args) == 0 {
		return r.GetByID(ctx, id)
	}

	args = append(args, id)
	query := fmt.Sprintf(`
		UPDATE exploit_block_rules
		SET %s
		WHERE id = $%d
		RETURNING id, category, name, pattern, pattern_type, COALESCE(description, ''), severity, enabled, is_system, sort_order, created_at, updated_at`,
		joinStrings(setClauses, ", "), argIndex)

	var rule model.ExploitBlockRule
	err := r.db.QueryRowContext(ctx, query, args...).Scan(
		&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
		&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
		&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update exploit rule: %w", err)
	}

	r.invalidateCache(ctx)
	return &rule, nil
}

// Delete deletes a custom exploit rule (system rules cannot be deleted)
func (r *ExploitBlockRuleRepository) Delete(ctx context.Context, id string) error {
	result, err := r.db.ExecContext(ctx, `
		DELETE FROM exploit_block_rules
		WHERE id = $1 AND is_system = false`, id)
	if err != nil {
		return fmt.Errorf("failed to delete exploit rule: %w", err)
	}

	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("rule not found or is a system rule")
	}

	r.invalidateCache(ctx)
	return nil
}

// ToggleEnabled toggles the enabled status of a rule
func (r *ExploitBlockRuleRepository) ToggleEnabled(ctx context.Context, id string) (*model.ExploitBlockRule, error) {
	query := `
		UPDATE exploit_block_rules
		SET enabled = NOT enabled, updated_at = CURRENT_TIMESTAMP
		WHERE id = $1
		RETURNING id, category, name, pattern, pattern_type, COALESCE(description, ''), severity, enabled, is_system, sort_order, created_at, updated_at`

	var rule model.ExploitBlockRule
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
		&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
		&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to toggle exploit rule: %w", err)
	}

	r.invalidateCache(ctx)
	return &rule, nil
}

// Global Exclusions

// GetGlobalExclusions returns all global rule exclusions
func (r *ExploitBlockRuleRepository) GetGlobalExclusions(ctx context.Context) ([]model.GlobalExploitRuleExclusion, error) {
	query := `
		SELECT id, rule_id, COALESCE(reason, ''), COALESCE(disabled_by, ''), created_at
		FROM global_exploit_rule_exclusions
		ORDER BY created_at DESC`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query global exclusions: %w", err)
	}
	defer rows.Close()

	var exclusions []model.GlobalExploitRuleExclusion
	for rows.Next() {
		var e model.GlobalExploitRuleExclusion
		if err := rows.Scan(&e.ID, &e.RuleID, &e.Reason, &e.DisabledBy, &e.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan global exclusion: %w", err)
		}
		exclusions = append(exclusions, e)
	}
	return exclusions, rows.Err()
}

// AddGlobalExclusion adds a global rule exclusion
func (r *ExploitBlockRuleRepository) AddGlobalExclusion(ctx context.Context, ruleID, reason, disabledBy string) (*model.GlobalExploitRuleExclusion, error) {
	query := `
		INSERT INTO global_exploit_rule_exclusions (rule_id, reason, disabled_by)
		VALUES ($1, $2, $3)
		ON CONFLICT (rule_id) DO UPDATE SET reason = $2, disabled_by = $3
		RETURNING id, rule_id, COALESCE(reason, ''), COALESCE(disabled_by, ''), created_at`

	var e model.GlobalExploitRuleExclusion
	err := r.db.QueryRowContext(ctx, query, ruleID, reason, disabledBy).Scan(
		&e.ID, &e.RuleID, &e.Reason, &e.DisabledBy, &e.CreatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to add global exclusion: %w", err)
	}

	r.invalidateCache(ctx)
	return &e, nil
}

// RemoveGlobalExclusion removes a global rule exclusion
func (r *ExploitBlockRuleRepository) RemoveGlobalExclusion(ctx context.Context, ruleID string) error {
	_, err := r.db.ExecContext(ctx, `
		DELETE FROM global_exploit_rule_exclusions WHERE rule_id = $1`, ruleID)
	if err != nil {
		return err
	}

	r.invalidateCache(ctx)
	return nil
}

// Host Exclusions

// GetHostExclusions returns exclusions for a specific host
func (r *ExploitBlockRuleRepository) GetHostExclusions(ctx context.Context, hostID string) ([]model.HostExploitRuleExclusion, error) {
	query := `
		SELECT id, proxy_host_id, rule_id, COALESCE(reason, ''), COALESCE(disabled_by, ''), created_at
		FROM host_exploit_rule_exclusions
		WHERE proxy_host_id = $1
		ORDER BY created_at DESC`

	rows, err := r.db.QueryContext(ctx, query, hostID)
	if err != nil {
		return nil, fmt.Errorf("failed to query host exclusions: %w", err)
	}
	defer rows.Close()

	var exclusions []model.HostExploitRuleExclusion
	for rows.Next() {
		var e model.HostExploitRuleExclusion
		if err := rows.Scan(&e.ID, &e.ProxyHostID, &e.RuleID, &e.Reason, &e.DisabledBy, &e.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan host exclusion: %w", err)
		}
		exclusions = append(exclusions, e)
	}
	return exclusions, rows.Err()
}

// AddHostExclusion adds a host-specific rule exclusion
func (r *ExploitBlockRuleRepository) AddHostExclusion(ctx context.Context, hostID, ruleID, reason, disabledBy string) (*model.HostExploitRuleExclusion, error) {
	query := `
		INSERT INTO host_exploit_rule_exclusions (proxy_host_id, rule_id, reason, disabled_by)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (proxy_host_id, rule_id) DO UPDATE SET reason = $3, disabled_by = $4
		RETURNING id, proxy_host_id, rule_id, COALESCE(reason, ''), COALESCE(disabled_by, ''), created_at`

	var e model.HostExploitRuleExclusion
	err := r.db.QueryRowContext(ctx, query, hostID, ruleID, reason, disabledBy).Scan(
		&e.ID, &e.ProxyHostID, &e.RuleID, &e.Reason, &e.DisabledBy, &e.CreatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to add host exclusion: %w", err)
	}

	r.invalidateCache(ctx)
	return &e, nil
}

// RemoveHostExclusion removes a host-specific rule exclusion
func (r *ExploitBlockRuleRepository) RemoveHostExclusion(ctx context.Context, hostID, ruleID string) error {
	_, err := r.db.ExecContext(ctx, `
		DELETE FROM host_exploit_rule_exclusions
		WHERE proxy_host_id = $1 AND rule_id = $2`, hostID, ruleID)
	if err != nil {
		return err
	}

	r.invalidateCache(ctx)
	return nil
}

// GetHostExclusionCounts returns the count of exclusions per host
func (r *ExploitBlockRuleRepository) GetHostExclusionCounts(ctx context.Context) (map[string]int, error) {
	query := `
		SELECT proxy_host_id, COUNT(*) as count
		FROM host_exploit_rule_exclusions
		GROUP BY proxy_host_id`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var hostID string
		var count int
		if err := rows.Scan(&hostID, &count); err != nil {
			return nil, err
		}
		counts[hostID] = count
	}
	return counts, rows.Err()
}

// GetRulesWithExclusionStatus returns all rules with their exclusion status for display
func (r *ExploitBlockRuleRepository) GetRulesWithExclusionStatus(ctx context.Context, hostID string) ([]model.ExploitBlockRuleWithStatus, error) {
	query := `
		SELECT
			r.id, r.category, r.name, r.pattern, r.pattern_type,
			COALESCE(r.description, '') as description,
			r.severity, r.enabled, r.is_system, r.sort_order,
			r.created_at, r.updated_at,
			CASE WHEN ge.id IS NOT NULL THEN true ELSE false END as globally_disabled,
			CASE WHEN he.id IS NOT NULL THEN true ELSE false END as host_disabled,
			ge.id as ge_id, ge.rule_id as ge_rule_id, COALESCE(ge.reason, '') as ge_reason,
			COALESCE(ge.disabled_by, '') as ge_disabled_by, ge.created_at as ge_created_at,
			he.id as he_id, he.proxy_host_id, he.rule_id as he_rule_id,
			COALESCE(he.reason, '') as he_reason, COALESCE(he.disabled_by, '') as he_disabled_by,
			he.created_at as he_created_at
		FROM exploit_block_rules r
		LEFT JOIN global_exploit_rule_exclusions ge ON r.id = ge.rule_id
		LEFT JOIN host_exploit_rule_exclusions he ON r.id = he.rule_id AND he.proxy_host_id = $1
		ORDER BY r.category, r.sort_order, r.name`

	rows, err := r.db.QueryContext(ctx, query, hostID)
	if err != nil {
		return nil, fmt.Errorf("failed to query rules with status: %w", err)
	}
	defer rows.Close()

	var rules []model.ExploitBlockRuleWithStatus
	for rows.Next() {
		var rule model.ExploitBlockRuleWithStatus
		var geID, geRuleID, geReason, geDisabledBy sql.NullString
		var geCreatedAt sql.NullTime
		var heID, heProxyHostID, heRuleID, heReason, heDisabledBy sql.NullString
		var heCreatedAt sql.NullTime

		if err := rows.Scan(
			&rule.ID, &rule.Category, &rule.Name, &rule.Pattern, &rule.PatternType,
			&rule.Description, &rule.Severity, &rule.Enabled, &rule.IsSystem,
			&rule.SortOrder, &rule.CreatedAt, &rule.UpdatedAt,
			&rule.GloballyDisabled, &rule.HostDisabled,
			&geID, &geRuleID, &geReason, &geDisabledBy, &geCreatedAt,
			&heID, &heProxyHostID, &heRuleID, &heReason, &heDisabledBy, &heCreatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan rule with status: %w", err)
		}

		if geID.Valid {
			rule.GlobalExclusion = &model.GlobalExploitRuleExclusion{
				ID:         geID.String,
				RuleID:     geRuleID.String,
				Reason:     geReason.String,
				DisabledBy: geDisabledBy.String,
				CreatedAt:  geCreatedAt.Time,
			}
		}
		if heID.Valid {
			rule.Exclusion = &model.HostExploitRuleExclusion{
				ID:          heID.String,
				ProxyHostID: heProxyHostID.String,
				RuleID:      heRuleID.String,
				Reason:      heReason.String,
				DisabledBy:  heDisabledBy.String,
				CreatedAt:   heCreatedAt.Time,
			}
		}

		rules = append(rules, rule)
	}
	return rules, rows.Err()
}

// GetRuleCount returns the total count of rules
func (r *ExploitBlockRuleRepository) GetRuleCount(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRowContext(ctx, `SELECT COUNT(*) FROM exploit_block_rules`).Scan(&count)
	return count, err
}

// GetCategoryCounts returns the count of rules per category
func (r *ExploitBlockRuleRepository) GetCategoryCounts(ctx context.Context) (map[string]int, error) {
	query := `
		SELECT category, COUNT(*) as count
		FROM exploit_block_rules
		GROUP BY category`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var category string
		var count int
		if err := rows.Scan(&category, &count); err != nil {
			return nil, err
		}
		counts[category] = count
	}
	return counts, rows.Err()
}

// GetRulesByPatternType returns rules grouped by pattern type (for nginx config generation)
func (r *ExploitBlockRuleRepository) GetRulesByPatternType(ctx context.Context, hostID string) (map[string][]model.ExploitBlockRule, error) {
	rules, err := r.GetEnabledForHost(ctx, hostID)
	if err != nil {
		return nil, err
	}

	result := make(map[string][]model.ExploitBlockRule)
	for _, rule := range rules {
		result[rule.PatternType] = append(result[rule.PatternType], rule)
	}
	return result, nil
}

// EnsureDefaultRulesExist checks if default rules exist and logs status
func (r *ExploitBlockRuleRepository) EnsureDefaultRulesExist(ctx context.Context) error {
	count, err := r.GetRuleCount(ctx)
	if err != nil {
		return fmt.Errorf("failed to check rule count: %w", err)
	}

	if count == 0 {
		return fmt.Errorf("no exploit block rules found - migration may not have run")
	}

	return nil
}

// invalidateCache invalidates all exploit rule caches
func (r *ExploitBlockRuleRepository) invalidateCache(ctx context.Context) {
	if r.cache != nil {
		_ = r.cache.InvalidateExploitRules(ctx)
		_ = r.cache.InvalidateAllExploitExclusions(ctx)
	}
}
